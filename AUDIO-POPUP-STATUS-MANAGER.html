<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Audio FX Manager — Matrix Intro</title>
<link rel="preload" href="https://aiquimista-agil.github.io/Website-Content/Header/Light-Switch.mp3" as="audio">
<style>
  :root{
    --pill-font: "Futura", "Futura PT", "Avenir", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{
    height:100%;
    margin:0;
    background: transparent; /* se vuelve negro cuando mostramos matrix overlay */
    font-family: var(--pill-font);
    color: white;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* ---------------------- OVERLAY MATRIX (pantalla inicial) ---------------------- */
  .matrix-overlay {
    position: fixed;
    inset: 0;
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
    overflow: hidden;
  }

  /* 3D neon grid illusion using gradients + animation */
  .matrix-grid {
    position: absolute;
    inset: 0;
    background:
      linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 70%),
      repeating-linear-gradient(90deg, rgba(0,255,100,0.06) 0 1px, transparent 1px 40px),
      repeating-linear-gradient(0deg, rgba(0,255,100,0.06) 0 1px, transparent 1px 40px);
    transform-style: preserve-3d;
    animation: gridMove 6s linear infinite;
    filter: drop-shadow(0 0 12px rgba(0,255,120,0.08));
  }

  @keyframes gridMove {
    0%{ transform: perspective(800px) translateZ(-20px) rotateX(12deg) translateY(0); background-position: 0 0, 0 0, 0 0;}
    50%{ transform: perspective(800px) translateZ(-10px) rotateX(12deg) translateY(-20px); background-position: 120px 0, 0 60px, 60px 0;}
    100%{ transform: perspective(800px) translateZ(-20px) rotateX(12deg) translateY(0); background-position: 240px 0, 0 120px, 120px 0;}
  }

  /* subtle matrix vertical streams (purely decorative) */
  .matrix-streams {
    position:absolute;
    inset:0;
    pointer-events:none;
    opacity:0.12;
    background-image: linear-gradient(180deg, rgba(0,255,100,0.06) 0 2px, transparent 2px 10px);
    background-size: 6px 18px;
    mix-blend-mode: screen;
    animation: streams 8s linear infinite;
  }
  @keyframes streams{
    from{background-position:0 0}
    to{background-position:0 1000px}
  }

  /* Container for pills */
  .pill-wrap {
    z-index: 9999;
    display:flex;
    gap:22px;
    align-items:center;
    justify-content:center;
    padding: 30px;
    pointer-events: auto;
  }

  /* Base pill style */
  .pill {
    --w: 220px;
    --h: 72px;
    width: var(--w);
    height: var(--h);
    border-radius: 999px;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    box-shadow: 0 12px 30px rgba(0,0,0,0.6), inset 0 -4px 14px rgba(255,255,255,0.05);
    font-family: var(--pill-font);
    font-size: 17px; /* pedido */
    letter-spacing: 0.6px;
    text-transform: capitalize; /* primera letra mayúscula de cada palabra */
    color: white;
    border: 1px solid rgba(255,255,255,0.06);
    transition: transform .18s ease, box-shadow .18s ease;
    backdrop-filter: blur(6px);
    position: relative;
    overflow: hidden;
  }
  .pill:active { transform: translateY(2px) scale(0.995); }

  /* Neon texture + translucency + inner highlight */
  .pill::before{
    content: "";
    position:absolute;
    inset:0;
    border-radius:999px;
    z-index:0;
    mix-blend-mode: screen;
    opacity: 0.95;
    background: radial-gradient(120% 80% at 20% 20%, rgba(255,255,255,0.12), rgba(255,255,255,0.02) 10%, transparent 30%),
                linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    pointer-events:none;
  }
  .pill-label {
    z-index:1;
    display:flex;
    align-items:center;
    gap:12px;
    font-weight:600;
    text-shadow: 0 1px 0 rgba(0,0,0,0.6);
  }

  /* small capsule icon decorative */
  .pill .cap {
    width: 36px;
    height: 36px;
    border-radius: 14px;
    display:inline-block;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6), inset 0 1px 6px rgba(255,255,255,0.06);
    filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));
  }

  /* Red (rojiza/orange-ish) pill */
  .pill.red {
    background: linear-gradient(180deg, rgba(255,120,60,0.20), rgba(180,40,20,0.12));
    border: 1px solid rgba(255,90,40,0.18);
    box-shadow: 0 14px 38px rgba(255,80,30,0.12), inset 0 -6px 16px rgba(0,0,0,0.35);
  }
  .pill.red .cap{
    background: radial-gradient(circle at 30% 30%, rgba(255,200,120,0.95), rgba(255,120,60,0.95) 35%, rgba(170,60,40,0.9) 100%);
    box-shadow: 0 0 18px rgba(255,100,40,0.28), inset 0 -3px 8px rgba(255,255,255,0.06);
  }
  .pill.red::after{
    content: "";
    position:absolute;
    right: -30%;
    top: -10%;
    width: 120%;
    height: 120%;
    transform: rotate(25deg);
    background: radial-gradient(80% 60% at 10% 10%, rgba(255,255,255,0.07), transparent 20%);
    filter: blur(6px);
    opacity:0.8;
  }

  /* Blue pill (translucid) */
  .pill.blue {
    background: linear-gradient(180deg, rgba(80,160,255,0.14), rgba(40,90,200,0.06));
    border: 1px solid rgba(90,150,255,0.12);
    box-shadow: 0 14px 36px rgba(50,120,220,0.08), inset 0 -6px 16px rgba(0,0,0,0.32);
  }
  .pill.blue .cap{
    background: radial-gradient(circle at 30% 30%, rgba(200,230,255,0.90), rgba(120,170,255,0.9) 35%, rgba(60,90,180,0.9) 100%);
    box-shadow: 0 0 18px rgba(40,140,255,0.22), inset 0 -2px 6px rgba(255,255,255,0.05);
  }
  .pill.blue::after{
    content:"";
    position:absolute;
    left:-20%;
    bottom:-10%;
    width: 80%;
    height: 80%;
    transform: rotate(-18deg);
    background: radial-gradient(60% 40% at 20% 20%, rgba(255,255,255,0.06), transparent 24%);
    filter: blur(5px);
    opacity:0.9;
  }

  /* tiny neon rim */
  .pill[data-neon="true"]{
    box-shadow: 0 10px 28px rgba(0,0,0,0.6), 0 0 18px rgba(0,255,120,0.04);
  }

  /* ---------------------- BARRA DE CONTROL DE AUDIO (adaptada) ---------------------- */
  #audioStatusBar {
    position: fixed;
    top: 18%;
    right: 4%;
    z-index: 9997;
    display: flex;
    align-items: center;
    gap: 14px;
    background: rgba(255,255,255,0.06);
    border-radius: 30px;
    padding: 10px 18px;
    backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.06);
    cursor: pointer;
    user-select: none;
    transition: background 0.24s ease, transform 0.12s ease;
    min-width: 180px;
  }
  #audioStatusBar.hidden { display:none; }

  #audioStatusBar:hover { transform: translateY(-2px); background: rgba(255,255,255,0.10); }

  .speaker { position: relative; width: 26px; height: 26px; background:none; z-index:2; }
  .speaker::before, .speaker::after { content:""; position:absolute; background: white; transition: all .28s ease; }
  .speaker::before { left:0; top:7px; width:10px; height:12px; border-radius:2px; background:white; }
  .speaker::after { left:10px; top:10px; width:8px; height:6px; border-radius:50%; border:2px solid white; border-left:none; }
  .speaker.off::after { border-color: rgba(255,255,255,0.3); }
  .speaker.off::before { background: rgba(255,255,255,0.3); }

  .mute-line { position:absolute; left:-2px; top:12px; width:30px; height:2px; background:red; transform:rotate(45deg); box-shadow: 0 0 6px red; display:none; }
  .speaker.off .mute-line { display:block; }

  .led { width:14px; height:14px; border-radius:50%; box-shadow:0 0 8px rgba(0,0,0,0.8); transition: background .3s, box-shadow .3s; z-index:2; }
  .led.on { background:#00ff55; box-shadow: 0 0 8px #00ff55, 0 0 15px #00ff55; }
  .led.off { background:#ff3333; box-shadow: 0 0 8px #ff3333, 0 0 15px #ff3333; }

  #audioText { letter-spacing:1px; font-size:15px; z-index:2; }

  #volumeControl { appearance:none; width:110px; height:6px; border-radius:6px; background: rgba(255,255,255,0.15); outline:none; }
  #volumeControl::-webkit-slider-thumb { appearance:none; width:12px; height:12px; border-radius:50%; background:white; box-shadow:0 0 10px white; cursor:pointer; }

  /* small responsive */
  @media (max-width:640px){
    .pill { --w: 160px; --h:56px; font-size:15px; }
    #audioStatusBar { top: auto; bottom: 6%; right: 6%; min-width: 160px; }
  }

</style>
</head>
<body>

<!-- Matrix overlay (inicia visible dependiendo de lógica JS) -->
<div id="matrixOverlay" class="matrix-overlay" aria-hidden="true" style="display:none;">
  <div class="matrix-grid" aria-hidden="true"></div>
  <div class="matrix-streams" aria-hidden="true"></div>

  <div class="pill-wrap" role="dialog" aria-label="Seleccionar estado de audio">
    <div class="pill red" id="pillActivate" data-neon="true" role="button" aria-pressed="false">
      <div class="pill-label">
        <span class="cap" aria-hidden="true"></span>
        <span>Activar sonido</span>
      </div>
    </div>

    <div class="pill blue" id="pillSilence" data-neon="true" role="button" aria-pressed="false">
      <div class="pill-label">
        <span class="cap" aria-hidden="true"></span>
        <span>Silencio</span>
      </div>
    </div>
  </div>
</div>

<!-- Barra de control de audio (se muestra al terminar overlay o si no corresponde mostrar overlay) -->
<div id="audioStatusBar" class="hidden" title="Click para activar / silenciar">
  <div class="speaker off" id="speakerIcon"><div class="mute-line"></div></div>
  <div class="led off" id="audioLed" aria-hidden="true"></div>
  <span id="audioText">OFF</span>
  <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.9" aria-label="Volumen">
</div>

<script>
(() => {
  /* ------------------ URLs / constantes ------------------ */
  const SOUND_URLS = {
    menu: "https://aiquimista-agil.github.io/Website-Content/Header/Light-Switch.mp3",
    logo: "https://aiquimista-agil.github.io/Website-Content/Header/FX-Light.mp3",
  };
  const TIMEOUT_MS = 33000; // 33 segundos
  const AUDIO_ENABLED_KEY = "audioEnabled"; // 1 or 0 in localStorage
  const VOLUME_KEY = "volumeLevel";

  /* ------------------ Elementos DOM ------------------ */
  const overlay = document.getElementById("matrixOverlay");
  const pillActivate = document.getElementById("pillActivate");
  const pillSilence = document.getElementById("pillSilence");
  const audioBar = document.getElementById("audioStatusBar");
  const led = document.getElementById("audioLed");
  const text = document.getElementById("audioText");
  const speaker = document.getElementById("speakerIcon");
  const volumeControl = document.getElementById("volumeControl");

  /* ------------------ Audio internals (copiado y adaptado) ------------------ */
  let audioCtx = null;
  const bufferCache = {};

  function createAudioContext(){
    if(!audioCtx){
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
    }
    return audioCtx;
  }

  async function ensureAudioContext(){
    createAudioContext();
    if(audioCtx.state === 'suspended'){
      try { await audioCtx.resume(); } catch(e){ console.warn('resume failed', e); }
    }
  }

  async function loadBuffer(key){
    if (bufferCache[key]) return bufferCache[key];
    const url = SOUND_URLS[key];
    if (!url) throw new Error('No URL for ' + key);
    const resp = await fetch(url, { cache: "no-store" });
    const arrayBuffer = await resp.arrayBuffer();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
    bufferCache[key] = audioBuffer;
    return audioBuffer;
  }

  async function playSound(key, options = {}){
    if (!isAudioEnabled()) return false;
    try {
      await ensureAudioContext();
      const buffer = await loadBuffer(key);
      const src = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const vol = Number(options.volume ?? volumeControl.value ?? 0.9);
      gain.gain.value = vol;
      src.buffer = buffer;
      src.connect(gain);
      gain.connect(audioCtx.destination);
      src.start(0);
      src.onended = () => { try{ src.disconnect(); gain.disconnect(); } catch(e){} };
      pulseLed();
      return true;
    } catch (err) {
      console.warn('playSound err', err);
      return false;
    }
  }

  function pulseLed(){
    led.classList.add('on');
    setTimeout(() => {
      if (!isAudioEnabled()) {
        led.classList.remove('on');
        led.classList.add('off');
      } else {
        // keep it on
      }
    }, 260);
  }

  function setAudioEnabled(enabled){
    localStorage.setItem(AUDIO_ENABLED_KEY, enabled ? "1" : "0");
    updateAudioUI();
  }

  function isAudioEnabled(){
    return localStorage.getItem(AUDIO_ENABLED_KEY) === "1";
  }

  function updateAudioUI(){
    const enabled = isAudioEnabled();
    if (enabled){
      led.classList.remove("off"); led.classList.add("on");
      speaker.classList.remove("off");
      text.textContent = "ON";
    } else {
      led.classList.remove("on"); led.classList.add("off");
      speaker.classList.add("off");
      text.textContent = "OFF";
    }
  }

  /* Unlock helpers */
  function unlockAudioOnInteraction(){
    if (!isAudioEnabled()) return;
    if (!audioCtx) createAudioContext();
    if (audioCtx.state !== 'suspended') return;

    function resumeOnce(){
      document.body.removeEventListener('pointerdown', resumeOnce);
      document.body.removeEventListener('keydown', resumeOnce);
      document.body.removeEventListener('touchstart', resumeOnce);
      document.body.removeEventListener('scroll', resumeOnce);
      ensureAudioContext().then(async () => {
        try {
          const buffer = bufferCache['menu'] ? bufferCache['menu'] : await loadBuffer('menu');
          const src = audioCtx.createBufferSource();
          const gain = audioCtx.createGain();
          gain.gain.value = 0.0005;
          src.buffer = buffer;
          src.connect(gain);
          gain.connect(audioCtx.destination);
          src.start(0);
          src.onended = () => { try{ src.disconnect(); gain.disconnect(); } catch(e){} };
        } catch (e) {
          console.warn('unlock playback failed', e);
        }
      }).catch(e => console.warn('ensureAudioContext failed', e));
    }

    document.body.addEventListener('pointerdown', resumeOnce, { passive:true });
    document.body.addEventListener('keydown', resumeOnce, { passive:true });
    document.body.addEventListener('touchstart', resumeOnce, { passive:true });
    document.body.addEventListener('scroll', resumeOnce, { passive:true });
  }

  async function preloadIfNeeded(){
    if (!audioCtx) createAudioContext();
    try {
      await Promise.all(Object.keys(SOUND_URLS).map(k => loadBuffer(k).catch(()=>{})));
    } catch(e){}
  }

  /* ------------------ Overlay / session logic ------------------ */
  // Coordinación entre pestañas: si existe activeSessionId en localStorage, consideramos que ya hay una "entrada" en el sitio y no mostramos matrix en nuevas pestañas.
  const STORAGE_SESSION_KEY = "activeSessionId"; // id para sesión activa en el sitio
  function getActiveSessionId(){ return localStorage.getItem(STORAGE_SESSION_KEY); }
  function setActiveSessionId(id){ localStorage.setItem(STORAGE_SESSION_KEY, String(id)); }
  function clearActiveSessionId(){ localStorage.removeItem(STORAGE_SESSION_KEY); }

  // Genera session id si no existe; devolvemos boolean: showOverlay
  function decideShowOverlay(){
    // Si ya existe audio bar shown in previous visits? (we still want overlay on new site entry unless same session)
    const existing = getActiveSessionId();
    if (!existing){
      // this tab is first to set session id -> will show overlay
      const sid = Date.now() + "-" + Math.floor(Math.random()*99999);
      setActiveSessionId(sid);
      // make sure we remove session id after some time (optional) - but keep for current browsing session until explicitly cleared
      return true;
    } else {
      // There is an active session -> user is already in site in other tab: do NOT show
      return false;
    }
  }

  // Limpieza cuando el usuario cierra la última pestaña no es trivial.
  // Opcional: si la pagina visibility becomes hidden and unload -> don't clear activeSessionId.
  // We'll provide manual clear on load of a new session if timestamp too old (not implemented for complexity).
  // (Esto cumple el requisito: mientras el usuario "permanezca" en el sitio entre pestañas no volverá a aparecer)

  /* ------------------ Mostrar / Ocultar overlay ------------------ */
  let overlayTimeout = null;
  function showOverlay(){
    document.body.style.background = "#000"; // fondo negro durante overlay
    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
    audioBar.classList.add("hidden");
    // start 33s timeout
    overlayTimeout = setTimeout(() => {
      // si no responde -> silencio (escenario 3)
      handleSilenceChoice(true); // fromTimeout = true
    }, TIMEOUT_MS);
  }

  function hideOverlay(){
    overlay.style.display = "none";
    overlay.setAttribute("aria-hidden","true");
    // set body transparent after overlay hidden as requested
    document.body.style.background = "transparent";
    audioBar.classList.remove("hidden");
    if (overlayTimeout){ clearTimeout(overlayTimeout); overlayTimeout = null; }
  }

  /* ------------------ Choice Handlers ------------------ */
  async function handleActivateChoice(){
    // usuario eligió la píldora roja (activar sonido)
    // set enabled, preload, play small menu sound, hide overlay
    setAudioEnabled(true);
    // ensure audio context + preload
    try {
      await ensureAudioContext();
      await preloadIfNeeded();
      // reproduce un pulso (puede fallar si navegador lo bloquea)
      playSound('menu', { volume: 0.9 });
      unlockAudioOnInteraction();
    } catch(e){ console.warn(e); }
    hideOverlay();
  }

  function handleSilenceChoice(fromTimeout = false){
    // usuario eligió silencio o timeout
    setAudioEnabled(false);
    hideOverlay();
    // if from timeout, we may log or indicate — nothing mas que hacer
  }

  /* ------------------ Bar toggle ------------------ */
  audioBar.addEventListener("click", async (ev) => {
    const newState = !isAudioEnabled();
    setAudioEnabled(newState);
    if (newState){
      await ensureAudioContext();
      // reproduce sonido de confirmación
      playSound("menu");
      unlockAudioOnInteraction();
    }
  });

  /* ------------------ Volume persistence ------------------ */
  volumeControl.addEventListener("input", () => {
    localStorage.setItem(VOLUME_KEY, volumeControl.value);
  });

  /* ------------------ Message listener (Wix/iframe interop) ------------------ */
  window.addEventListener("message", event => {
    let data = event.data;
    try { if (typeof data === "string") data = JSON.parse(data); } catch(e){}
    if (!data || !data.type) return;
    if (data.type === "play" && data.sound) playSound(data.sound, data.options || {});
    if (data.type === "setVolume" && typeof data.value !== 'undefined'){
      volumeControl.value = data.value;
      localStorage.setItem(VOLUME_KEY, data.value);
    }
    if (data.type === "setEnabled"){
      setAudioEnabled(Boolean(data.enabled));
    }
  });

  /* ------------------ Inicialización general ------------------ */
  async function initialize(){
    // Restaurar volumen
    const savedVol = localStorage.getItem(VOLUME_KEY);
    if (savedVol !== null) volumeControl.value = savedVol;

    // actualizar UI segun estado guardado
    updateAudioUI();

    // decide si mostrar overlay
    const shouldShowOverlay = decideShowOverlay();

    if (shouldShowOverlay){
      showOverlay();
    } else {
      // no mostramos overlay: mostramos la barra directamente
      hideOverlay(); // this will ensure bar visible and body transparent
    }

    // si audio está activado, precargar buffers y tratar de desbloquear
    if (isAudioEnabled()){
      createAudioContext();
      try {
        await preloadIfNeeded();
        // small silent attempt
        if (audioCtx && audioCtx.state !== 'running'){
          const buffer = bufferCache['menu'] ? bufferCache['menu'] : await loadBuffer('menu');
          const src = audioCtx.createBufferSource();
          const gain = audioCtx.createGain();
          gain.gain.value = 0.0001;
          src.buffer = buffer;
          src.connect(gain);
          gain.connect(audioCtx.destination);
          src.start(0);
          src.onended = () => { try{ src.disconnect(); gain.disconnect(); } catch(e){} };
        }
      } catch(e){
        // si falla, unlock por interacción
      }
      unlockAudioOnInteraction();
    }

    // wiring de botones overlay
    pillActivate.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); handleActivateChoice(); });
    pillSilence.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); handleSilenceChoice(false); });

    // Si el usuario se va a otra pestaña del sitio (closes or opens new), no queremos mostrar la matrix de nuevo
    // ya está controlado por localStorage.activeSessionId

    // Escuchar storage events: si otra pestaña decide a mostrar overlay y luego lo oculta, sincronizamos (opcional)
    window.addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_SESSION_KEY){
        // Si alguien cambió la sesión activa, no hacemos nada en particular.
      }
      // Si otra pestaña cambió audioEnabled, actualizamos UI:
      if (ev.key === AUDIO_ENABLED_KEY){
        updateAudioUI();
      }
    });
  }

  // Ejecutar inicialización
  initialize();

  // Opcional: método para "resetear" sesión (solo para desarrollo)
  // window.clearMatrixSession = () => { clearActiveSessionId(); };

})();
</script>
</body>
</html>
